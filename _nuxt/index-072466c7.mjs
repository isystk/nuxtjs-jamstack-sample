var b=Object.defineProperty;var p=Object.getOwnPropertySymbols;var x=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable;var g=(e,n,a)=>n in e?b(e,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[n]=a,D=(e,n)=>{for(var a in n||(n={}))x.call(n,a)&&g(e,a,n[a]);if(p)for(var a of p(n))C.call(n,a)&&g(e,a,n[a]);return e};import{i as P,j as l,k as O,l as R,m as _,n as z,p as B,q as M,s as j}from"./entry-655f910a.mjs";const A=e=>P(e)?e:l(e),E=()=>null;function T(e,n,a={}){var d,h,m,y,v;if(typeof e!="string")throw new TypeError("asyncData key must be a string");if(typeof n!="function")throw new TypeError("asyncData handler must be a function");a=D({server:!0,default:E},a),a.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),a.lazy=(h=(d=a.lazy)!=null?d:a.defer)!=null?h:!1,a.initialCache=(m=a.initialCache)!=null?m:!0;const r=O(),f=B();if(f&&!f._nuxtOnBeforeMountCbs){const i=f._nuxtOnBeforeMountCbs=[];f&&(R(()=>{i.forEach(s=>{s()}),i.splice(0,i.length)}),_(()=>i.splice(0,i.length)))}const c=()=>a.initialCache&&r.payload.data[e]!==void 0,t={data:A((y=r.payload.data[e])!=null?y:a.default()),pending:l(!c()),error:l((v=r.payload._errors[e])!=null?v:null)};t.refresh=(i={})=>r._asyncDataPromises[e]?r._asyncDataPromises[e]:i._initial&&c()?r.payload.data[e]:(t.pending.value=!0,r._asyncDataPromises[e]=Promise.resolve(n(r)).then(s=>{a.transform&&(s=a.transform(s)),a.pick&&(s=I(s,a.pick)),t.data.value=s,t.error.value=null}).catch(s=>{t.error.value=s,t.data.value=M(a.default())}).finally(()=>{t.pending.value=!1,r.payload.data[e]=t.data.value,t.error.value&&(r.payload._errors[e]=!0),delete r._asyncDataPromises[e]}),r._asyncDataPromises[e]);const u=()=>t.refresh({_initial:!0}),w=a.server!==!1&&r.payload.serverRendered;{w&&r.isHydrating&&e in r.payload.data?t.pending.value=!1:f&&r.payload.serverRendered&&(r.isHydrating||a.lazy)?f._nuxtOnBeforeMountCbs.push(u):u(),a.watch&&z(a.watch,()=>t.refresh());const i=r.hook("app:data:refresh",s=>{if(!s||s.includes(e))return t.refresh()});f&&_(i)}const o=Promise.resolve(r._asyncDataPromises[e]).then(()=>t);return Object.assign(o,t),o}function I(e,n){const a={};for(const r of n)a[r]=e[r];return a}var q=j.exports;export{q as a,T as u};
